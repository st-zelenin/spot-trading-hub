# Spot Trading Hub - Cursor Rules

## Project Overview
This is a TypeScript/Node.js Express application for managing crypto exchange spot orders. It provides a unified API for multiple cryptocurrency exchanges (Binance, Bybit) with support for order management, trade history, and real-time data via WebSockets.

## Technology Stack
- **Runtime**: Node.js (v18+)
- **Language**: TypeScript (ES2020, strict mode)
- **Framework**: Express.js v5
- **API Documentation**: TSOA (TypeScript OpenAPI) with Swagger
- **Databases**: Azure Cosmos DB, MongoDB
- **Exchanges**: Binance, Bybit
- **Linting**: ESLint with TypeScript plugin
- **Formatting**: Prettier
- **Testing**: Jest

## Code Style & Conventions

### Naming Conventions
- **Interfaces**: PascalCase, NO `I` prefix (e.g., `ExchangeService`, not `IExchangeService`)
- **Classes**: PascalCase (e.g., `OrderController`, `BinanceService`)
- **Files**: kebab-case (e.g., `exchange-service.ts`, `order-dto.ts`)
- **Variables/Functions**: camelCase (e.g., `getOrderHistory`, `exchangeService`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `CONTAINER_NAMES`)

### TypeScript Best Practices
1. **Always use explicit type annotations** for function parameters and return types
2. **Never use `any`** - use `unknown` when type is truly unknown, then narrow it
3. **Prefer interfaces over type aliases** for object shapes
4. **Use `readonly`** for properties that shouldn't be modified after initialization
5. **Always use explicit access modifiers** (`public`, `private`, `protected`) for all class members
6. **Enable strict TypeScript** - the project uses strict mode with all strict checks enabled

### File Organization
```
src/
├── config/           # Configuration (env, swagger)
├── controllers/      # API controllers (TSOA decorators)
├── models/           # Data models
│   └── dto/          # Data Transfer Objects
├── routes/           # API routes (generated by TSOA)
├── services/         # Business logic
│   ├── interfaces/   # Service interfaces
│   ├── binance/      # Binance-specific services
│   ├── bybit/        # Bybit-specific services
│   └── trading/      # Trading services
└── utils/            # Utility functions
```

### Service Layer Architecture
- **Interface Segregation**: Each service interface defines specific operations
- **Factory Pattern**: Use `ExchangeFactory` to create exchange service instances
- **Dependency Injection**: Services receive dependencies through constructors
- **Base Services**: Common functionality in base classes (e.g., `BaseCosmosDbService`, `BaseMongodbService`)

### Controller Layer
- Use TSOA decorators (`@Route`, `@Get`, `@Post`, `@Tags`, `@SuccessResponse`)
- Controllers handle HTTP requests and delegate to services
- Always return `ApiResponse<T>` format: `{ success: boolean, data: T }`
- Use JSDoc comments for all public methods with `@param` and `@returns`

### DTOs (Data Transfer Objects)
- Place all DTOs in `src/models/dto/`
- Use `readonly` properties for request DTOs
- Include JSDoc comments with `@example` tags
- Group related DTOs in the same file (e.g., `order-dto.ts`)

### Error Handling
- Use standardized error response format across the application
- Log errors with context using the logger utility
- Use the `errorHandlingMiddleware` for centralized error handling
- Always handle errors with proper type checking: `error instanceof Error ? error.message : 'Unknown error'`

### Documentation
- **JSDoc**: Add JSDoc comments for all public methods, interfaces, and classes
- Include parameter descriptions (`@param`) and return type information (`@returns`)
- Add examples (`@example`) where appropriate
- **Code Comments**: Only add comments for complex logic, non-obvious decisions, or important warnings
- Let clean, readable code speak for itself - avoid obvious comments

### Logging
- Use the centralized logger from `src/utils/logger`
- Include relevant context in log messages (exchange, symbol, orderId, etc.)
- Use appropriate log levels: `info`, `warn`, `error`

### Database Services
- Use base services (`BaseCosmosDbService`, `BaseMongodbService`) for common operations
- Initialize services in `src/index.ts` before starting the server
- Handle initialization errors gracefully with try-catch
- Close database connections during graceful shutdown

### Environment Configuration
- Use `envalid` for environment variable validation
- Access env variables through `src/config/env.ts`
- Never hardcode configuration values

## Code Quality

### Linting & Formatting
- **ESLint**: Follow `.eslintrc.js` configuration
  - Max line length: 120 characters
  - Explicit member accessibility required
  - Explicit function return types required
  - No `any` types allowed
  - Unused variables allowed only with `_` prefix
- **Prettier**: Follow `.prettierrc` configuration
  - Single quotes
  - Trailing commas (ES5)
  - Print width: 120
  - Tab width: 2 spaces
  - Semicolons: yes
  - Bracket spacing: yes

### Pre-commit Hooks
- Husky runs lint-staged on pre-commit
- All staged `.ts` files are formatted with Prettier and linted with ESLint
- Ensure code passes all checks before committing

### Git Workflow
- Use conventional commit format:
  - Types: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`
  - Format: `type(scope): description` or `type: description`
  - Example: `feat(order): add cancel order endpoint` or `fix: resolve memory leak`
- Use feature branches for new features
- Use bugfix branches for bug fixes

## Development Guidelines

### Adding New Exchange Support
1. Create exchange-specific service implementing `ExchangeService` interface
2. Create exchange-specific DB service extending base service
3. Add exchange type to `ExchangeType` enum
4. Update `ExchangeFactory` to handle new exchange
5. Follow existing patterns from Binance/Bybit implementations

### Adding New API Endpoints
1. Add method to appropriate controller with TSOA decorators
2. Use appropriate DTOs for request/response
3. Delegate business logic to services
4. Return `ApiResponse<T>` format
5. Run `npm run tsoa:generate` to regenerate routes and Swagger docs

### Testing
- Write unit tests for business logic
- Write integration tests for API endpoints
- Use Jest as the testing framework
- Aim for high test coverage

### Building & Running
- Development: `npm run dev` (uses nodemon with dotenv)
- Build: `npm run build` (generates TSOA routes and compiles TypeScript)
- Production: `npm run prod` (build + start)
- Validate: `npm run validate` (format + lint + check)

## Common Patterns

### Service Factory Pattern
```typescript
const exchangeService = ExchangeFactory.getExchangeService(exchange);
```

### Error Handling Pattern
```typescript
try {
  // operation
} catch (error: unknown) {
  logger.error('Operation failed', {
    error: error instanceof Error ? error.message : 'Unknown error',
  });
  throw error;
}
```

### Controller Response Pattern
```typescript
return {
  success: true,
  data: result,
};
```

### Interface Definition Pattern
```typescript
/**
 * Description of the interface
 */
export interface ServiceName {
  /**
   * Method description
   * @param param Description
   * @returns Return description
   */
  methodName(param: Type): Promise<ReturnType>;
}
```

## Things to Avoid
- ❌ Using `any` type
- ❌ Interfaces with `I` prefix
- ❌ Missing type annotations
- ❌ Missing access modifiers on class members
- ❌ Hardcoding configuration values
- ❌ Ignoring error handling
- ❌ Committing code that doesn't pass linting/formatting
- ❌ Adding comments to self-explanatory code
- ❌ Using camelCase for file names
- ❌ Mixing database access patterns (use base services)

## When Making Changes
1. Follow existing patterns and architecture
2. Maintain type safety - no `any` types
3. Add JSDoc comments for public APIs
4. Update Swagger docs by running `npm run tsoa:generate`
5. Run `npm run validate` before committing
6. Ensure all tests pass
7. Handle errors appropriately with logging

